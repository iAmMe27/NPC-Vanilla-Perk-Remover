using Noggog;
using Mutagen.Bethesda;
using Mutagen.Bethesda.Synthesis;
using Mutagen.Bethesda.Skyrim;
using Mutagen.Bethesda.Plugins;
using Mutagen.Bethesda.Plugins.Cache;
using Mutagen.Bethesda.FormKeys.SkyrimSE;
using Mutagen.Bethesda.WPF.Reflection.Attributes;
using Mutagen.Bethesda.Plugins.Order;

namespace NPCVanillaPerkRemover
{
    public class Settings
    {
        [SettingName("NPC Blacklist")]
        [Tooltip("Enter Editor IDs of NPCs you want this patcher to ignore.")]
        public List<FormLink<INpcGetter>> NpcBlacklist = [];
        
        [SettingName("Perk Blacklist")]
        [Tooltip("Enter Editor IDs of perks you want this patcher to ignore.")]
        public List<FormLink<IPerkGetter>> PerkBlacklist = [];
    }
    
    public class Program
    {
        private static Lazy<Settings> _settings = null!;
        private static int _count;
        
        // logging stuff
        private static HashSet<FormKey> LoggedPerks = [];
        private static StreamWriter? _logWriter;
        
        public static async Task<int> Main(string[] args)
        {
            return await SynthesisPipeline.Instance
                .AddPatch<ISkyrimMod, ISkyrimModGetter>(RunPatch)
                .SetAutogeneratedSettings("settings", "settings.json", out _settings)
                .SetTypicalOpen(GameRelease.SkyrimSE, "RemoveVanillaPerks.esp")
                .Run(args);
        }

        public static void RunPatch(IPatcherState<ISkyrimMod, ISkyrimModGetter> state)
        {
            InitLogger(state.DataFolderPath, state.LinkCache);

            try
            {
                var vanillaLinkCache = LoadOrder
                    .Import<ISkyrimModGetter>(state.DataFolderPath,
                        new List<ModKey>() { Skyrim.ModKey, Dawnguard.ModKey, Dragonborn.ModKey }, GameRelease.SkyrimSE)
                    .PriorityOrder.ToImmutableLinkCache();

                foreach (var npcGetter in state.LoadOrder.PriorityOrder.Npc().WinningOverrides())
                {
                    if (npcGetter.EditorID is null) continue;
                    if (npcGetter.Configuration.Flags.HasFlag(NpcConfiguration.Flag.IsCharGenFacePreset) || npcGetter.HasKeyword(Skyrim.Keyword.PlayerKeyword)) continue;
                    if (_settings.Value.NpcBlacklist.Any(link => link.FormKey == npcGetter.FormKey)) continue;

                    var npc = npcGetter.DeepCopy();
                    if (npc.Perks is null || npc.Perks.Count <= 0) continue;

                    RemoveVanillaPerks(npc, vanillaLinkCache);
                    state.PatchMod.Npcs.Set(npc);

                    _count++;
                    if (_count % 100 == 0) Console.WriteLine($"{_count} NPCs processed.");
                }
            }
            finally
            {
                CloseLogger();
            }
        }
        
        // Logger stuff to keep track of what perks were removed
        private static void InitLogger(string outputPath, ILinkCache<ISkyrimMod, ISkyrimModGetter> linkCache)
        {
            var logPath = Path.Combine(outputPath, "RemovedPerks.txt");
            _logWriter = new StreamWriter(logPath, append: false)
            {
                AutoFlush = true
            };
            
            _logWriter?.WriteLine($"[{DateTime.Now}] Begin patching.");
            
            // Log NPC blacklist
            if (_settings.Value.NpcBlacklist.Count > 0)
            {
                _logWriter?.WriteLine("[INFO] NPC Blacklist:");
                foreach (var npcLink in _settings.Value.NpcBlacklist)
                {
                    if (linkCache.TryResolve<INpcGetter>(npcLink, out var npc))
                    {
                        var editorId = npc.EditorID ?? string.Empty;
                        var name = npc.Name?.ToString() ?? string.Empty;
                        var formKey = npc.FormKey.ToString();
                        _logWriter?.WriteLine($"{editorId}, {name}, {formKey}");
                    }
                    else
                    {
                        _logWriter?.WriteLine($"Could not resolve {npcLink.FormKey}");
                    }
                }
            }
            else
            {
                _logWriter?.WriteLine("NPC Blacklist: (empty)");
            }
            
            // Log perk blacklist
            if (_settings.Value.PerkBlacklist.Count > 0)
            {
                _logWriter?.WriteLine("[INFO] Perk Blacklist:");
                foreach (var perkLink in _settings.Value.PerkBlacklist)
                {
                    if (linkCache.TryResolve<IPerkGetter>(perkLink, out var perk))
                    {
                        var editorId = perk.EditorID ?? string.Empty;
                        var name = perk.Name?.ToString() ?? string.Empty;
                        var formKey = perk.FormKey.ToString();
                        _logWriter?.WriteLine($"{editorId}, {name}, {formKey}");
                    }
                    else
                    {
                        _logWriter?.WriteLine($"Could not resolve {perkLink.FormKey}");
                    }
                }
            }
            else
            {
                _logWriter?.WriteLine("Perk Blacklist: (empty)");
            }
        }
        
        private static void CloseLogger()
        {
            _logWriter?.WriteLine($"[{DateTime.Now}] Finished patching.");
            _logWriter?.Dispose();
        }
        
        // Code adapted from TrueUnleveledSkyrim: https://github.com/ReaperAnon/True-Unleveled-Skyrim
        private static void RemoveVanillaPerks(Npc npc, ILinkCache vanillaLinkCache)
        { 
            if (npc.Perks is null || npc.Perks.Count <= 0) return;
            
            for(var i= npc.Perks.Count - 1; i >= 0; --i)
            {
                var perkRef = npc.Perks[i].Perk;
                
                // Always keep the base skill boosts.
                if (perkRef.Equals(Skyrim.Perk.AlchemySkillBoosts) || perkRef.Equals(Skyrim.Perk.PerkSkillBoosts)) continue;
                
                // Skip perk if it's blacklisted
                //if (_settings.Value.PerkBlacklist.Any(link => link.FormKey == perkRef.FormKey)) continue;
                
                if (_settings.Value.PerkBlacklist.Any(link =>
                        vanillaLinkCache.TryResolve<IPerkGetter>(link, out var blacklistedPerk) &&
                        vanillaLinkCache.TryResolve<IPerkGetter>(perkRef, out var thisPerk) &&
                        blacklistedPerk.FormKey == thisPerk.FormKey))
                {
                    continue;
                }
                
                // Remove perk if present in the vanilla cache.
                if (vanillaLinkCache.TryResolve<IPerkGetter>(perkRef, out var perkGetter))
                {
                    npc.Perks.RemoveAt(i);
                    
                    if (LoggedPerks.Add(perkRef.FormKey))
                    {
                        var perkEditorId = perkGetter.EditorID ?? string.Empty;
                        var perkName = perkGetter.Name?.ToString() ?? string.Empty;
                        var perkFormKey = perkGetter.FormKey.ToString() ?? string.Empty;
                        
                        _logWriter?.WriteLine($"Removed perk: {perkEditorId}, {perkName}, {perkFormKey}");
                    }
                }
            }
        }
    }
}
